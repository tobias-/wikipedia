

 overhead of scope/stack management on return.

=== Subroutines ===
[[Subroutine]]s are defined with the <code>sub</code> keyword, and invoked simply by naming them. If the subroutine in question has not yet been declared, invocation requires either parentheses after the function name or an ampersand ('''&''') before it.

<source lang="perl">
# Calling a subroutine

# Parentheses are required here if the subroutine is defined later in the code
foo();
&foo; # (this also works)

# Defining a subroutine
sub foo { ... }

foo; # Here parentheses are not required
</source>

A list of arguments may be provided after the subroutine name. Arguments may be scalars, lists, or hashes.

foo $x, @y, %z;

The parameters to a subroutine do not need to be declared as to either number or type; in fact, they may vary from call to call. Any validation of parameters must be performed explicitly inside the subroutine.

Arrays are expanded to their elements, hashes are expanded to a list of key/value pairs, and the whole lot is passed into the subroutine as one flat list of scalars.

Whatever arguments are passed are available to the subroutine in the special array <code>@_</code>. The elements of <code>@_</code> are aliased to the actual arguments; changing an element of <code>@_</code> changes the corresponding argument.

Elements of <code>@_</code> may be accessed by subscripting it in the usual way.

<source lang="perl">
$_[0], $_[1]
</source>

However, the resulting code can be difficult to read, and the parameters have [[Evaluation strategy#Call by reference|pass-by-reference]] semantics, which may be undesirable.

One common idiom is to assign <code>@_</code> to a list of named variables.

<source lang="perl">
 my ($x, $y, $z) = @_;
</source>

This provides mnemonic parameter names and implements [[Evaluation strategy#Call by value|pass-by-value]] semantics. The <code>my</code> keyword indicates that the following variables are lexically scoped to the containing block.

Another idiom is to shift parameters off of <code>@_</code>. This is especially common when the subroutine takes only one argument, or for handling the <code>$self</code> argument in object-oriented modules.

<source lang="perl">
my $x = shift;
</source>

Subroutines may assign <code>@_</code> to a hash to simulate named arguments; this is recommended in ''Perl Best Practices'' for subroutines that are likely ever to have more than three parameters.<ref>
Damian Conway, ''[http://www.oreilly.com/catalog/perlbp/chapter/ch09.pdf Perl Best Practices]'', p.182</ref>

<source lang="perl">
sub function1 {
 my %args = @_;
 print "'x' argument was '$args{x}'\n";
}
function1( x => 23 );
</source>

Subroutines may return values.

<source lang="perl">
return 42, $x, @y, %z;
</source>

If the subroutine does not exit via a <code>return</code> statement, then it returns the last expression evaluated within the subroutine body. Arrays and hashes in the return value are expanded to lists of scalars, just as they are for arguments.

The returned expression is evaluated in the calling context of the subroutine; this can surprise the unwary.

<source lang="perl">
sub list { (4, 5, 6) }
sub array { @x = (4, 5, 6); @x }

$x = list; # returns 6 - last element of list
$x = array; # returns 3 - number of elements in list
@x = list; # returns (4, 5, 6)
@x = array; # returns (4, 5, 6)
</source>

A subroutine can discover its calling context with the <code>wantarray</code> function.

<source lang="perl">
sub either {
 return wantarray ? (1, 2) : "Oranges";
}

$x = either; # returns "Oranges"
@x = either; # returns (1, 2)
</source>

=== Regular expressions ===
The Perl language includes a specialized syntax for writing [[regular expression]]s (RE, or regexes), and the interpreter contains an engine for matching strings to regular expressions. The regular expression engine uses a [[backtracking]] algorithm, extending its capabilities from simple pattern matching to string capture and substitution. The regular expression engine is derived from regex written by [[Henry Spencer]].

The Perl regular expression syntax was originally taken from Unix Version 8 regular expressions. However, it diverged before the first release of Perl, and has since grown to include many more features. Other languages and applications are now adopting [[PCRE|Perl compatible regular expressions]] over [[POSIX]] regular expressions including [[PHP]], [[Ruby programming language|Ruby]], [[Java (programming language)|Java]], Microsoft's [[.NET Framework]]<ref>Microsoft Corp., ".NET Framework Regular Expressions", ''.NET Framework Developer's Guide'', [http://msdn2.microsoft.com/en-us/library/hs600312(VS.71).aspx]</ref>, and the [[Apache HTTP server]].

Regular expression syntax is extremely compact, owing to history. The first regular expression dialects were only slightly more expressive than [[Glob (programming)|globs]], and the syntax was designed so that an expression would resemble the text it matches{{Fact|date=June 2007}}. This meant using no more than a single punctuation character or a pair of delimiting characters to express the few supported assertions. Over time, the expressiveness of regular expressions grew tremendously, but the syntax design was never revised and continues to rely on punctuation. As a result, regular expressions can be cryptic and extremely dense.

==== Uses ====
The <code>m//</code> (match) operator introduces a regular expression match. (If you use slashes as delimiters, as in all the examples here, then the leading <code>m</code> may be omitted for brevity.) In the simplest case, an expression like

<source lang="perl">
$x =~ m/abc/
</source>

evaluates to true [[if and only if]] the string <code>$x</code> matches the regular expression <code>abc</code>.

The <code>s///</code> (substitute) operator, on the other hand, specifies a search and replace operation:

<source lang="perl">
$x =~ s/abc/aBc/; # upcase the b
</source>

Another use of regular expressions is to specify delimiters for the <code>split</code> function:

<source lang="perl">
@words = split m/,/, $line;
</source>

The <code>split</code> function creates a list of the parts of the string separated by matches of the regular expression. In this example, a line is divided into a list of its comma-separated parts, and this list is then assigned to the <code>@words</code> array.

==== Syntax ====
Portions of a regular expression may be enclosed in parentheses; corresponding portions of a matching string are ''captured''. Captured strings are assigned to the sequential built-in variables <code>$1, $2, $3, ...</code>, and a list of captured strings is returned as the value of the match.

<source lang="perl">
$x =~ m/a(.)c/; # capture the character between 'a' and 'c'
</source>

Perl regular expressions can take ''modifiers''. These are single-letter suffixes that modify the meaning of the expression:

<source lang="perl">
$x =~ m/abc/i; # case-insensitive pattern match
$x =~ s/abc/aBc/g; # global search and replace
</source>

Since regular expressions can be dense and cryptic because of their compact syntax, the <code>/x</code> modifier was added in Perl to help programmers write more legible regular expressions. It allows programmers to place whitespace and comments ''inside'' regular expressions:

<source lang="perl">
$x =~ m/a # match 'a'
 . # followed by any character
 c # then followed by the 'c'character
 /x;
</source>

== Database interfaces ==
Perl is widely favored for database applications. Its text handling facilities are useful for generating [[SQL]] queries; arrays, hashes and automatic memory management make it easy to collect and process the returned data.

In early versions of Perl, database interfaces were created by relinking the interpreter with a client-side database library. This was sufficiently difficult that it was only done for a few of the most important and widely used databases, and restricted the resulting <code>perl</code> executable to using just one database interface at a time.

In Perl 5, database interfaces are implemented by [[Perl DBI]] modules. The DBI (Database Interface) module presents a single, database-independent interface to Perl applications, while the DBD (Database Driver) modules handle the details of accessing some 50 different databases; there are DBD drivers for most [[American National Standards Institute|ANSI]] [[SQL]] databases.

DBI provides caching for database handles and queries, which can greatly improve performance in long-lived execution environments such as [[mod_perl]]<ref>{{cite web | last = Bekman | first = Stas | title = Efficient Work with Databases under mod_perl | url = http://perl.apache.org/docs/1.0/guide/performance.html#Efficient_Work_with_Databases_under_mod_perl | accessdate = 2007-09-01 }}</ref>, helping high-volume systems avert load spikes as in the [[Slashdot effect]].

== Comparative performance ==
''The Computer Language Benchmarks Game''<ref>[http://shootout.alioth.debian.org/ The Computer Language Benchmarks Game<!-- Bot generated title -->]</ref> compare the performance of implementations of typical programming problems in several programming languages. The submitted Perl implementations were typically towards the high end of the memory usage spectrum, and had varied speed results. Perl's performance in the benchmarks game is similar to other interpreted languages such as Python, faster than PHP, and significantly faster than Ruby, but slower than most compiled languages.

Perl programs can start slower than similar programs in compiled languages because perl has to compile the source every time it runs. In a talk at the [[YAPC|YAPC::Europe 2005]] conference and subsequent article, "A Timely Start", Jean-Louis Leroy found that his Perl programs took much longer to run than he expected because the perl interpreter spent much of the time finding modules because of his over-large include path.<ref>{{cite web | url=http://www.perl.com/pub/a/2005/12/21/a_timely_start.html | title=A Timely Start | author=Leroy, Jean-Louis | date=2005-12-01 | publisher=Perl.com }}</ref> Because pre-compiling is still an experimental part of Perl<ref>{{cite web | url=http://search.cpan.org/~nwclark/perl-5.8.8/ext/B/B/Bytecode.pm#KNOWN_BUGS | title=B::Bytecode Perl compiler's bytecode backend | author=Beattie, Malcolm and Enache Adrian | year=2003 | publisher=search.cpan.org }}</ref> – unlike that of Java, Python, and Ruby – Perl programs pay this overhead penalty on every execution. When [[amortized]] over a long run phase, startup time is not typically substantial, but measurement of very short execution times can often be skewed as is often found in benchmarks.

A number of tools have been introduced to improve this situation, the first of which was Apache's [[mod_perl]], which sought to address one of the most common reasons that small Perl programs were invoked rapidly: [[Common Gateway Interface|CGI]] [[World Wide Web|Web]] development. [[ActiveState|ActivePerl]], via Microsoft [[ISAPI]] provides similar performance improvements.

Once Perl code is compiled, there is additional overhead during the execution phase that typically isn't present for programs written in compiled languages like C or C++, including, among many other things, overhead due to bytecode interpretation, reference-counting memory management, and dynamic type checking.

=== Optimizing ===
Perl programs, like any code, can be [[Optimization (computer science)|tuned for performance]] using [[Benchmark (computing)|benchmarks]] and [[Performance analysis|profiles]] after a readable and correct implementation is finished. In part because of Perl's interpreted nature, writing more-efficient Perl will not always be enough to meet one's performance goals for a program.

In such situations, the most critical routines of a Perl program can be written in other languages such as [[C (programming language)|C]] or [[Assembly language|Assembler]], which can be connected to Perl via simple Inline modules or the more complex but flexible [[XS (Perl)|XS]] mechanism.<ref>http://search.cpan.org/perldoc/Inline/</ref> Nicholas Clark, a Perl core developer, discusses some Perl design trade-offs and some solutions in ''When perl is not quite fast enough''.<ref>[http://www.ccl4.org/~nick/P/Fast_Enough/ When perl is not quite fast enough<!-- Bot generated title -->]</ref>

In extreme cases, optimizing Perl can require intimate knowledge of the interpreter's workings rather than skill with algorithms, the Perl language, or general principles of optimization.{{Fact|date=July 2007}}

== Future ==
{{main|Perl 6}}
At the 2000 [[Perl Conference]], [[Jon Orwant]] made a case for a major new language initiative.<ref>[http://www.nntp.perl.org/group/perl.perl6.meta/424 Transcription of Larry's talk]. Retrieved on 2006 September 28.</ref> This led to a decision to begin work on a redesign of the language, to be called Perl 6. Proposals for new language features were solicited from the Perl community at large, and over 300 [[Request for Comments|RFCs]] were submitted.

[[Larry Wall]] spent the next few years digesting the RFCs and synthesizing them into a coherent framework for Perl 6. He has presented his design for Perl 6 in a series of documents called "apocalypses", which are numbered to correspond to chapters in ''[[Programming Perl]]'' ("The Camel Book"). The current, not yet finalized specification of Perl 6 is encapsulated in design documents called Synopses, which are numbered to correspond to Apocalypses.

Perl 6 is not intended to be backward compatible, though there will be a compatibility mode.

In [[2001]], it was decided that Perl 6 would run on a cross-language [[virtual machine]] called [[Parrot virtual machine|Parrot]]. This will mean that other languages targeting the Parrot will gain native access to [[CPAN]], allowing some level of cross-language development.

In [[2005]] [[Audrey Tang]] created the [[pugs]] project, an implementation of Perl 6 in [[Haskell (programming language)|Haskell]]. This was and continues to act as a test platform for the Perl 6 language (separate from the development of the actual implementation) allowing the language designers to explore. The pugs project spawned an active Perl/Haskell cross-language community centered around the [[freenode]] #perl6 irc channel.

A number of features in the Perl 6 language now show similarities with Haskell, and Perl 6 has been embraced by the Haskell community as a potential scripting language{{Fact|date=October 2007}}.

[[As of 2006]], Perl 6, Parrot, and pugs are under active development, and a new module for Perl 5 called [[v6 (Perl)|v6]] allows some Perl 6 code to run directly on top of Perl 5.

In 2006, an effort was started to have Windows Perl distributions ship with a compiler, in order to make the need for binary packages on Windows redundant. Some early results of this include the CamelPack macro-installer<ref>[http://camelpack.sourceforge.net/ Camel Pack]</ref> and Vanilla Perl<ref>[http://win32.perl.org/wiki/index.php?title=Vanilla_Perl Vanilla Perl]</ref> and Strawberry Perl<ref>[http://strawberryperl.com/ Strawberry Perl site]</ref>.

Development of Perl 5 is also continuing. Perl 5.10 was released in December of 2007, with some new features influenced by the design of Perl 6.

== The Perl community ==
Perl's culture and community has developed alongside the language itself. [[Usenet]] was the first public venue in which Perl was introduced, but over the course of its evolution, Perl's community was shaped by the growth of broadening Internet-based services including the introduction of the World Wide Web. The community that surrounds Perl was, in fact, the topic of Larry Wall's first "State of the Onion" talk.<ref>{{ cite web | url=http://www.wall.org/~larry/keynote/keynote.html | title=Perl Culture (AKA the first State of the Onion) | first=Larry | last=Wall | authorlink=Larry Wall | date=1997-08-20 }}</ref>

=== State of the Onion ===
State of the Onion is the name for Larry Wall’s yearly [[keynote]]-style summaries on the progress of Perl and its community.  They are characterized by his hallmark humor, employing references to Perl’s and the wider hacker culture, as well as Wall’s linguistic and sometimes his Christian background.

Each talk is first given at various Perl conferences and eventually also published online.

=== Pastimes ===
Perl's pastimes have become a defining element of the community. Included among them are trivial and complex uses of the language.

==== JAPHs ====
In email, Usenet and message board postings, "[[Just another Perl hacker]]" (JAPH) programs have become a common trend, originated by [[Randal L. Schwartz]], one of the earliest professional Perl trainers.<ref>{{cite newsgroup | author = [[Randal L. Schwartz]] | title = Who is Just another Perl hacker? | id = m1hfpvh2jq.fsf@halfdome.holdit.com | newsgroup = comp.lang.perl.misc | date = 1999-05-02 | url = http://groups.google.com/groups?selm=m1hfpvh2jq.fsf@halfdome.holdit.com | accessdate = 2007-11-12 }}</ref>

In the parlance of Perl culture, Perl programmers are known as Perl hackers, and from this derives the practice of writing short programs to print out the phrase "[[Just another Perl hacker]],". In the spirit of the original concept, these programs are moderately obfuscated and short enough to fit into the signature of an email or Usenet message. The "canonical" JAPH includes the comma at the end, although this is often omitted.

==== Perl golf ====
Perl "golf" is the pastime of reducing the number of characters used in a Perl program to the bare minimum, much as how [[golf]] players seek to take as few shots as possible in a round. This use of the word "golf" originally focused on the JAPHs used in signatures in Usenet postings and elsewhere, though the same stunts had been an unnamed pastime in the language [[APL_(programming_language)|APL]] in previous decades. The use of Perl to write a program which performed [[RSA]] encryption prompted a widespread and practical interest in this pastime.<ref>[http://www.cypherspace.org/adam/rsa/story.html The quest for the most diminutive munitions program<!-- Bot generated title -->]</ref> In subsequent years, code golf has been taken up as a pastime in other languages besides Perl.<ref>{{cite web | url=http://codegolf.com/ | title=Code Golf: What is Code Golf? | publisher=29degrees | date=2007 }}</ref>

==== Obfuscation ====
As with C, [[obfuscated code]] competitions are a well-known pastime. The annual [[Obfuscated Perl contest]] made an arch virtue of Perl's syntactic flexibility.

==== Poetry ====
Similar to obfuscated code and golf, but with a different purpose, Perl poetry is the practice of writing poems that can actually be compiled as legal (although generally non-sensical) Perl code. This hobby is more or less unique to Perl due to the large number of regular English words used in the language. New poems are regularly published in the [[Perl Monks]] site's Perl Poetry section.<ref>[http://www.perlmonks.org/?node_id=1590 Perl Poetry section] on [[Perl Monks]]</ref>

==== CPAN Acme ====
There are also many examples of code written purely for entertainment on the CPAN. <code>Lingua::Romana::Perligata</code>, for example, allows writing programs in [[Latin]].<ref>{{ cite web | url=http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html | title=Lingua::Romana::Perligata -- Perl for the XXI-imum Century | author=Conway, Damian }}</ref> Upon execution of such a program, the module translates its source code into regular Perl and runs it.

The Perl community has set aside the "[[Acme Corporation|Acme]]" namespace for modules that are fun in nature (but its scope has widened to include exploratory or experimental code or any other module that is not meant to ever be used in production). Some of the Acme modules are deliberately implemented in amusing ways. This includes <code>Acme::Bleach</code>, one of the first modules in the <code>Acme::</code> namespace,<ref>{{cite web | url=http://use.perl.org/~acme/journal/200 | title=use Perl; Journal of acme | date=2001-05-23 | author=Brocard, Leon }}</ref> which allows the program's source code to be "whitened" (i.e., all characters replaced with whitespace) and yet still work.

These are also examples of "source filters"; libraries which transform the text of a program before reading it.

== Further reading ==
* ''[[Learning Perl]]'', Fourth Edition (the ''Llama book''), ISBN 0-596-10105-8
* ''[[Perl Cookbook]]'', ISBN 0-596-00313-7
* ''[[Programming Perl]]'', (the ''Camel book''), ISBN 0-596-00027-8

== See also ==
{{portal|Free software|Free Software Portal Logo.svg}}
* [[The Perl Foundation]]
* [[v:Topic:Perl|Perl]] instruction at Wikiversity - you can use the training and/or help add to it
* [[Perl Object Environment]] (POE) - a framework for writing persistent object-oriented environments with [[event loop]]s.
* [[Perl Data Language]] (PDL) - a Perl module which allows extending Perl for higher-order scientific processing.
* [[Plain Old Documentation]] (POD) - a documentation tool for Perl.
* [[Just another Perl hacker]] (JAPH)
* [[Perl Monks]]
* [[Perl Mongers]]
* [[PerlScript]]
* [[Perl 6]]
* [[Comparison of programming languages]]
* [[Autovivification]]

== References ==
{{reflist|2}}

== External links ==
<!-- Before adding any links, make sure you have read the External Links style guide, then stopped and reread it again. If you aren't absolutely sure the link is in compliance, ask on the talk page first -->
{{wikibooks|Perl Programming}}
{{wikiversity2|Topic:Perl}}
* [http://www.perl.org/ Perl.org] - Official Perl website
* [http://perldoc.perl.org/ Perl documentation]
* [http://www.perlfoundation.org/ The Perl Foundation]
* [http://www.perlfoundation.org/perl5/ Official Perl 5 Wiki]
* {{dmoz|Computers/Programming/Languages/Perl/|Perl}}

[[Category:Perl|*]]
[[Category:Curly bracket programming languages]]
[[Category:Dynamic programming languages]]
[[Category:Dynamically-typed programming languages]]
[[Category:Free compilers and interpreters]]
[[Category:Procedural programming languages]]
[[Category:Programming languages]]
[[Category:Scripting languages]]
[[Category:Text-oriented programming languages]]
[[Category:Unix software]]

[[als:Perl]]
[[ar:بيرل]]
[[bn:পার্ল (প্রোগ্রামিং ভাষা)]]
[[zh-min-nan:Perl]]
[[bs:Perl]]
[[bg:Пърл (език за програмиране)]]
[[ca:Perl]]
[[cs:Perl]]
[[cy:Perl]]
[[da:Perl]]
[[pdc:Perl]]
[[de:Perl]]
[[et:Perl]]
[[el:Perl]]
[[es:Perl]]
[[eo:Perl]]
[[eu:Perl]]
[[fa:پرل]]
[[fr:Perl (langage)]]
[[gl:Perl]]
[[ko:펄]]
[[hr:Perl]]
[[id:Perl]]
[[it:Perl]]
[[he:Perl]]
[[ka:პერლი]]
[[ku:Perl]]
[[la:Perl]]
[[lb:Perl (Programméiersprooch)]]
[[lt:Perl]]
[[hu:Perl]]
[[ml:പേള്‍]]
[[ms:Perl]]
[[nl:Perl (programmeertaal)]]
[[ja:Perl]]
[[no:Perl]]
[[nn:Perl]]
[[pl:Perl]]
[[pt:Perl]]
[[ro:Perl]]
[[ru:Perl]]
[[sq:Perl]]
[[simple:Perl]]
[[sk:Perl]]
[[sl:Perl]]
[[sr:Програмски језик Перл]]
[[fi:Perl]]
[[sv:Perl]]
[[ta:பெர்ள்]]
[[th:ภาษาเพิร์ล]]
[[vi:Perl]]
[[tg:Перл (забони барномасозӣ)]]
[[tr:Perl]]
[[uk:Perl]]
[[bat-smg:Perl]]
[[zh:Perl]]