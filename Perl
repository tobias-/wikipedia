Perl was originally named "Pearl", after the [[Parable of the Pearl]] from the [[Gospel of Matthew]]. Larry Wall wanted to give the language a short name with positive connotations; he claims that he considered (and rejected) every three- and four-letter word in the dictionary. He also considered naming it after his wife Gloria. Wall discovered the existing [[PEARL (programming language)|PEARL]] programming language before Perl's official release and changed the spelling of the name.

The name is normally capitalized (''Perl'') when referring to the language and uncapitalized (''perl'') when referring to the interpreter program itself since Unix-like file systems are case-sensitive. Before the release of the first edition of ''Programming Perl'', it was common to refer to the language as ''perl''; [[Randal L. Schwartz]], however, capitalised the language's name in the book to make it stand out better when typeset. The case distinction was subsequently adopted by the community.<ref>{{cite web | url=http://perldoc.perl.org/perlfaq1.html#What's-the-difference-between-%22perl%22-and-%22Perl%22%3f | title=perlfaq1: What's the difference between "perl" and "Perl"?}}</ref>

The name is occasionally given as "PERL" (for '''P'''ractical '''E'''xtraction and '''R'''eport '''L'''anguage). Although the expansion has prevailed in many of today's manuals, including the official Perl [[Manual page (Unix)|man page]], it is merely a [[backronym]]. The name does not officially stand for anything, so spelling it in all caps is incorrect. Proper capitalisation is considered a [[shibboleth]] (label of insiders) in the Perl community.<ref>{{cite web | last = Schwartz | first = Randal | authorlink = Randal L. Schwartz | title = PERL as shibboleth and the Perl community | url=http://www.perlmonks.org/index.pl?node_id=510594 | accessdate = 2007-06-01 }}</ref> Several other expansions have been suggested, including Wall's own humorous ''Pathologically Eclectic Rubbish Lister''.<ref>{{ cite web | last = Wall | first = Larry | authorlink = Larry Wall | title = BUGS | work = perl(1) [[man page]] | url = http://perldoc.perl.org/perl.html#BUGS | accessdate = 2006-10-13 }}</ref> Indeed, Wall claims that the name was intended to inspire many different expansions.<ref>{{cite web | last = Wall | first = Larry | authorlink = Larry Wall | title = Re^7: PERL as shibboleth and the Perl community | url =http://www.perlmonks.org/index.pl?node_id=511722 | accessdate = 2007-01-03 }}</ref>

=== The camel symbol ===
''[[Programming Perl]]'', published by [[O'Reilly Media]], features a picture of a [[camel]] on the cover, and is commonly referred to as ''The Camel Book''.<ref name="larry-wall-snippet"/> This image of a camel has become a general symbol of Perl.

O'Reilly owns the image as a trademark, but claims to use their legal rights only to protect the ''"integrity and impact of that symbol"''.<ref>http://perl.oreilly.com/usage/</ref>
O'Reilly allows non-commercial use of the symbol, and provides ''Programming Republic of Perl'' logos and ''Powered by Perl'' buttons.<ref>[http://www.oreillynet.com/images/perl/ Index of /images/perl<!-- Bot generated title -->]</ref>

== Overview ==
Perl is a general-purpose programming language originally developed for text manipulation and now used for a wide range of tasks including [[system administration]], [[web development]], [[network programming]], [[GUI]] development, and more.

The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal).<ref>perlintro(1) [[man page]]</ref> Its major features include support for multiple programming paradigms ([[procedural programming language|procedural]], [[Object-oriented programming|object-oriented]], and [[functional programming|functional]] styles), [[reference counting]] [[memory management]] (without a cycle detecting garbage collector), built-in support for text processing, and a large collection of third-party [[Module (programming)|modules]].

=== Features ===
The overall structure of Perl derives broadly from C. Perl is procedural in nature, with [[variable]]s, [[expression (programming)|expressions]], [[assignment statement]]s, [[bracket|brace]]-delimited [[code block]]s, [[control structure]]s, and [[subroutine]]s.

Perl also takes features from shell programming. All variables are marked with leading [[sigil (computer programming)|sigils]], which unambiguously identify the data type (scalar, array, hash, etc.) of the variable in context. Importantly, sigils allow variables to be interpolated directly into strings. Perl has many built-in functions which provide tools often used in shell programming (though many of these tools are implemented by programs external to the shell) like sorting, and calling on system facilities.

Perl takes [[List (computing)|lists]] from Lisp, [[associative array]]s (hashes) from AWK, and [[regular expression]]s from sed. These simplify and facilitate many parsing, text handling, and data management tasks.

In Perl 5, features were added that support complex [[data structure]]s, [[first-class function]]s (i.e., [[Closure (computer science)|closures]] as values), and an object-oriented programming model. These include [[reference (computer science)|references]], packages, class-based method dispatch, and [[Scope (programming)|lexically scoped variables]], along with [[compiler directive]]s (for example, the <tt>strict</tt> pragma). A major additional feature introduced with Perl 5 was the ability to package code as reusable modules. Larry Wall later stated that "The whole intent of Perl 5's module system was to encourage the growth of Perl culture rather than the Perl core."<ref>Usenet post, May 10th 1997, with ID 199705101952.MAA00756@wall.org.</ref>

All versions of Perl do automatic data typing and memory management. The interpreter knows the type and storage requirements of every data object in the program; it allocates and frees storage for them as necessary using [[reference counting]] (so it cannot deallocate circular data structures without manual intervention). Legal type conversions—for example, conversions from number to string—are done automatically at run time; illegal type conversions are fatal errors.

=== Design ===
The design of Perl can be understood as a response to three broad trends in the computer industry: falling hardware costs, rising labor costs, and improvements in compiler technology. Many earlier computer languages, such as [[Fortran]] and C, were designed to make efficient use of expensive computer hardware. In contrast, Perl is designed to make efficient use of expensive computer programmers.

Perl has many features that ease the programmer's task at the expense of greater CPU and memory requirements. These include automatic memory management; [[dynamic typing]]; strings, lists, and hashes; regular expressions; introspection and an <tt>eval()</tt> function.

Wall was trained as a linguist, and the design of Perl is very much informed by linguistic principles. Examples include [[Huffman coding]] (common constructions should be short), good end-weighting (the important information should come first), and a large collection of language primitives. Perl favors language constructs that are concise and natural for humans to read and write, even where they complicate the Perl interpreter.

Perl syntax reflects the idea that "things that are different should look different". For example, scalars, arrays, and hashes have different leading [[Sigil (computer programming)|sigils]]. Array indices and hash keys use different kinds of braces. Strings and regular expressions have different standard delimiters. This approach can be contrasted with languages like [[Lisp programming language|Lisp]], where the same [[S-expression]] construct and basic syntax is used for many different purposes.

Perl does not enforce any particular programming paradigm (procedural, object-oriented, functional, etc.) or even require the programmer to choose among them.

There is a broad practical bent to both the Perl language and the community and culture that surround it. The preface to ''Programming Perl'' begins, "Perl is a language for getting your job done." One consequence of this is that Perl is not a tidy language. It includes many features, tolerates exceptions to its rules, and employs heuristics to resolve syntactical ambiguities. Because of the forgiving nature of the compiler, bugs can sometimes be hard to find. Discussing the variant behaviour of built-in functions in list and scalar contexts, the perlfunc(1) manual page says "In general, they do what you want, unless you want consistency."

Perl has several mottos that convey aspects of its design and use. One is ''"[[There's more than one way to do it]]."'' (TIMTOWTDI, usually pronounced 'Tim Toady'). Others are ''"Perl: the Swiss Army Chainsaw of Programming Languages"'' and ''"No unnecessary limits"''. A stated design goal of Perl is to make easy tasks easy and difficult tasks possible. Perl has also been called ''"The Duct Tape of the Internet"''.<ref>{{cite web | url = http://www.oreillynet.com/pub/a/oreilly/perl/news/importance_0498.html | title = The Importance of Perl | year = 1998 | month = April | publisher = O'Reilly & Associates, Inc. | quote = As Hassan Schroeder, Sun's first webmaster, remarked: “Perl is the duct tape of the Internet.” }}</ref>

There is no written specification or standard for the Perl language, and no plans to create one for the current version of Perl. There has only been one implementation of the interpreter. That interpreter, together with its functional tests, stands as a ''de facto'' specification of the language.

=== Applications ===
Perl has many and varied applications, compounded by the availability of many standard and third-party modules.

Perl has been used since the early days of the Web to write [[Common Gateway Interface|CGI]] scripts. It is known as one of "the three Ps" (along with [[Python (programming language)|Python]] and [[PHP]]), the most popular dynamic languages for writing Web applications (which now also include [[Ruby (programming language)|Ruby]]). It is also an integral component of the popular [[LAMP (software bundle)|LAMP]] [[solution stack]] for web development. Large projects written in Perl include [[Slash (weblog system)|Slash]], [[Bugzilla]], [[TWiki]] and [[Movable Type]]. Many high-traffic websites, such as [[bbc.co.uk]], [[Amazon.com]], [[LiveJournal]].com, [[Ticketmaster]].com and [[Internet Movie Database|IMDb.com]]<ref>{{cite web | title = IMDb Helpdesk: What software/hardware are you using to run the site? | url = http://www.imdb.com/help/search?domain=helpdesk_faq&index=1&file=techinfo | accessdate = 2007-09-01 }}</ref> use Perl extensively.

Perl is often used as a [[glue language]], tying together systems and interfaces that were not specifically designed to interoperate, and for "data munging", i.e., converting or processing large amounts of data for tasks like creating reports. In fact, these strengths are intimately linked. The combination makes perl a popular all-purpose tool for [[system administrator]]s, particularly as short programs can be entered and run on a single command line.

With a degree of care, Perl code can be made portable across Windows and Unix. Portable Perl code is often used by suppliers of software (both COTS and bespoke) to simplify packaging and maintenance of software build and deployment scripts.

Graphical user interfaces (GUI's) may be developed using Perl. In particular, Perl/Tk is commonly used to enable user interaction with Perl scripts. Such interaction may be synchronous or asynchronous using callbacks to update the GUI. For more information about the technologies involved see [[Tk (computing)|Tk]],[[Tcl]] and [[WxPerl]].

Perl is also widely used in finance and [[bioinformatics]], where it is valued for rapid application development and deployment, and the ability to handle large data sets.

=== Implementation ===
Perl is implemented as a core interpreter, written in C, together with a large collection of modules, written in Perl and C. The source distribution is, [[as of 2005]], 12 [[megabyte|MB]] when packaged in a [[Tar (file format)|tar file]] and [[data compression|compressed]]. The interpreter is 150,000 lines of C code and compiles to a 1 MB executable on typical machine architectures. Alternatively, the interpreter can be compiled to a link library and embedded in other programs. There are nearly 500 modules in the distribution, comprising 200,000 lines of Perl and an additional 350,000 lines of C code. (Much of the C code in the modules consists of character encoding tables.)

The interpreter has an object-oriented architecture. All of the elements of the Perl language&mdash;scalars, arrays, hashes, coderefs, file handles&mdash;are represented in the interpreter by C structs. Operations on these structs are defined by a large collection of macros, typedefs and functions; these constitute the Perl C API. The Perl API can be bewildering to the uninitiated, but its entry points follow a consistent naming scheme, which provides guidance to those who use it.

The execution of a Perl program divides broadly into two phases: compile-time and run-time.<ref>A description of the Perl 5 interpreter can be found in ''Programming Perl'', 3rd Ed., [http://www.oreilly.com/catalog/pperl3/chapter/ch18.html chapter 18]</ref> At compile time, the interpreter parses the program text into a syntax tree. At run time, it executes the program by walking the tree. The text is parsed only once, and the syntax tree is subject to optimization before it is executed, so the execution phase is relatively efficient. Compile-time optimizations on the syntax tree include [[constant folding]] and context propagation, but [[peephole optimization]] is also performed. However, compile-time and run-time phases may nest: <code>BEGIN</code> code blocks execute at compile-time, while the <code>[[eval]]</code> function initiates compilation during runtime. Both operations are an implicit part of a number of others—most notably, the <code>use</code> clause that loads libraries, known in Perl as modules, implies a <code>BEGIN</code> block.

Perl has a context-sensitive [[grammar]] which can be affected by code executed during an intermittent run-time phase.<ref>{{cite web | last = Schwartz | first = Randal | authorlink = Randal L. Schwartz | title = On Parsing Perl | url =http://www.perlmonks.org/index.pl?node_id=44722 | accessdate = 2007-01-03 }}</ref> Therefore Perl cannot be parsed by a straight [[Lex programming tool|Lex]]/[[Yacc]] lexer/parser combination. Instead, the interpreter implements its own lexer, which coordinates with a modified [[GNU bison]] parser to resolve ambiguities in the language. It is said that "only perl can parse Perl", meaning that only the [[Perl interpreter]] (''perl'') can parse the Perl language (''Perl''). The truth of this is attested to by the persistent imperfections of other programs that undertake to parse Perl, such as source code analyzers and auto-indenters, which have to contend not only with the many ways to express unambiguous syntactic constructs, but also the fact that Perl cannot be parsed in the general case without executing it. Though successful in creating a Perl parser for document-related purposes, the PPI project determined that parsing Perl code as a document (retaining its integrity) and as executable code simultaneously was, in fact, not possible. Specifically the author claimed that, "parsing Perl suffers from the '[[Halting problem|Halting Problem]].'"<ref>{{cite web | url=http://search.cpan.org/~adamk/PPI-1.201/lib/PPI.pm | title=PPI - Parse, Analyze and Manipulate Perl (without perl) | author=Kennedy, Adam | year=2006 | publisher=[[CPAN]]}}</ref>

Perl is distributed with some 120,000 functional tests. These run as part of the normal build process, and extensively exercise the interpreter and its core modules. Perl developers rely on the functional tests to ensure that changes to the interpreter do not introduce bugs; conversely, Perl users who see the interpreter pass its functional tests on their system can have a high degree of confidence that it is working properly.

Maintenance of the Perl interpreter has become increasingly difficult over the years. The code base has been in continuous development since 1994. The code has been optimized for performance at the expense of simplicity, clarity, and strong internal interfaces. New features have been added, yet virtually complete backward compatibility with earlier versions is maintained. The size and complexity of the interpreter is a barrier to developers who wish to work on it.

=== Availability ===
<!--Note to editors:
Perl is available on so many platforms that it doesn't make sense to keep a laundry list in this article.
Do not list a specific platform unless there are notable issues about running Perl on it.

-->Perl is [[free software]], and is licensed under both the [[Artistic License]] and the [[GNU General Public License]]. [[Perl#Distributions|Distributions]] are available for most [[operating system]]s. It is particularly prevalent on [[Unix]] and [[Unix-like]] systems, but it has been ported to most modern (and many obsolete) platforms. With only six reported exceptions, Perl can be compiled from [[source code]] on all Unix-like, [[POSIX]]-compliant or otherwise Unix-compatible platforms.<ref name="cpanports">{{cite web | url=http://www.cpan.org/ports/ | title=Perl Ports (Binary Distributions) | publisher=CPAN.org | author=Hietaniemi, Jarkko | year=1998}}</ref> However, this is rarely necessary, as Perl is included in the default installation of many popular operating systems.

Because of unusual changes required for the [[Mac OS history|Mac OS Classic]] environment, a special port called MacPerl was shipped independently.<ref name="macperl">{{cite web | url=http://www.macperl.com/ | title=The MacPerl Pages | year=1997 | publisher=Prime Time Freeware}}</ref>

The CPAN carries a complete list of supported platforms with links to the distributions available on each.<ref>[http://www.cpan.org/ports/ CPAN/ports<!-- Bot generated title -->]</ref>

== Language structure ==
In Perl, the minimal [[Hello world]] program may be written as follows:
<source lang="perl">
print "Hello, world!\n"
</source>
This [[Input/output|prints]] the [[String (computer science)|string]] ''Hello, world!'' and a [[newline]], symbolically expressed by an <code>n</code> character whose interpretation is altered by the preceding backslash.

The canonical form of the program is slightly more verbose:

<source lang="perl">
#!/usr/bin/perl
print "Hello, world!\n";
</source>

The hash mark character introduces a [[comment (computer programming)|comment]] in Perl, which runs up to the end of the line of code and is ignored by the compiler. The comment used here is of a special kind: it’s called the [[Shebang (Unix)|shebang]] line. This tells Unix-like operating systems where to find the Perl interpreter, making it possible to invoke the program without explicitly mentioning <code>perl</code>. (Note that on [[Microsoft Windows]] systems, Perl programs are typically invoked by associating the <code>.pl</code> [[Filename extension|extension]] with the Perl interpreter. In order to deal with such circumstances, <code>perl</code> detects the shebang line and parses it for switches,<ref name="cpanports">{{cite web | url=http://perldoc.perl.org/perlrun.html#DESCRIPTION | title=perlrun manpage}}</ref> so it is not strictly true that the shebang line is ignored by the compiler.)

The second line in the canonical form includes a semicolon, which is used to separate statements in Perl. With only a single statement in a block or file, a separator is unnecessary, so it can be omitted from the minimal form of the program – or more generally from the final statement in any block or file. The canonical form includes it because it is common to terminate every statement even when it is unnecessary to do so, as this makes editing easier: code can be added to or moved away from the end of a block or file without having to adjust semicolons.

Version 5.10 of Perl introduces a <code>say</code> function that implicitly appends a newline character to its output, making the minimal "Hello world" program even shorter:

<source lang="perl">
say 'Hello, world!'
</source>

=== Data types ===
Perl has a number of fundamental [[data type]]s, the most commonly used and discussed being: [[Scalar (computing)|scalars]], [[array]]s, [[Hash table|hashes]], [[filehandle]]s and [[subroutines]]:
* A [[Scalar (computing)|scalar]] is a single value; it may be a number, a [[String (computer science)|string]] or a [[Reference (computer science)|reference]]
* An [[array]] is an ordered collection of scalars
* A hash, or [[associative array]], is a map from strings to scalars; the strings are called ''keys'' and the scalars are called ''values''.
* A [[file handle]] is a map to a file, device, or pipe which is open for reading, writing, or both.
* A subroutine is a piece of code that may be passed arguments, be executed, and return data

Most variables are marked by a leading [[Sigil (computer programming)|sigil]], which identifies the data type being accessed (not the type of the variable itself), except filehandles, which don't have a sigil. The same name may be used for variables of different data types, without conflict.

<source lang="perl">
$foo # a scalar
@foo # an array
%foo # a hash
FOO # a file handle or constant
&foo # a subroutine. (The & is optional)
</source>

[[File handle]]s and constants need not be uppercase, but it is a common convention owing to the fact that there is no sigil to denote them. Both are global in scope, but file handles are interchangeable with references to file handles, which can be stored in scalars, which in turn permit lexical scoping. Doing so is encouraged in [[Damian Conway]]'s ''Perl Best Practices''. As a convenience, the <code>open</code> function in Perl 5.6 and newer will autovivify undefined scalars to file handle references.

Numbers are written in the bare form; strings are enclosed by quotes of various kinds.

<source lang="perl">
$name = "joe";
$color = 'red';

$number1 = 42;
$number2 = "42";

# This evaluates to true
if ($number1 == $number2) { print "Numbers and strings of numbers are the same!"; }

$answer = "The answer is $number1"; # Variable interpolation: The answer is 42
$price = 'This device costs $42'; # No interpolation in single quotes

$album = "It's David Bowie's \"Heroes\""; # literal quotes inside a string;
$album = 'It\'s David Bowie\'s "Heroes"'; # same as above with single quotes;
$album = q(It's David Bowie's "Heroes"); # the quote-like operators q() and qq() allow
 # almost any delimiter instead of quotes, to
 # avoid excessive backslashing

$multilined_string =<<EOF;
This is my multilined string
note that I am terminating it with the "EOF" word.
EOF
</source>

Perl will convert strings into numbers and vice versa depending on the context in which they are used. In the following example the strings $n and $m are treated as numbers when they are the arguments to the addition operator. This code prints the number '5', discarding non numeric information for the operation, although the variable values remain the same. (The string concatenation operator is the period, not the <code>+</code> symbol.)

<source lang="perl">
$n = "3 apples";
$m = "2 oranges";
print $n + $m;
</source>

Perl also has a boolean context that it uses in evaluating conditional statements. The following values all evaluate as false in Perl:

<source lang="perl">
$false = 0; # the number zero
$false = 0.0; # the number zero as a float
$false = 0b0; # the number zero in binary
$false = 0x0; # the number zero in hexadecimal
$false = '0'; # the string zero
$false = ""; # the empty string
$false = undef; # the return value from undef
</source>

All other values are evaluated to true. This includes the odd self-describing literal string of "0 but true", which in fact is 0 as a number, but true when used as a boolean. (Any non-numeric string would also have this property, but this particular string is ignored by Perl with respect to numeric warnings.) A less explicit but more conceptually portable version of this string is '0E0' or '0e0', which does not rely on characters being evaluated as 0, as '0E0' is literally "zero times ten to the zeroth power."

Evaluated boolean expressions also return scalar values. Although the documentation does not promise which ''particular'' true or false is returned (and thus cannot be relied on), many boolean operators return 1 for true and the empty-string for false (which evaluates to zero in a numeric context). The ''defined()'' function tells if the variable has any value set. In the above examples ''defined($false)'' is true for every value except ''undef''.

If a specifically 1 or 0 result (as in C) is needed, an explicit conversion is thought by some authors to be required:

<source lang="perl">
my $real_result = $boolean_result ? 1 : 0;
</source>

However, if it's known that the value is either 1 or ''undef'', an implicit conversion can be used instead:

<source lang="perl">
my $real_result = $boolean_result + 0;
</source>

A list is written by listing its elements, separated by commas, and enclosed by parentheses where required by operator precedence.

<source lang="perl">
@scores = (32, 45, 16, 5);
</source>

It can be written many other ways as well, some straightforward and some less so:

<source lang="perl">
# An explicit and straightforward way
@scores = ('32', '45', '16', '5');

# Equivalent to the above, but the qw() quote-like operator saves typing of
# quotes and commas and reduces visual clutter; almost any delimiter can be
# used instead of parentheses
@scores = qw(32 45 16 5);

# The split function returns a list of strings, which are extracted
# from the expression using a regex template.
# This may be useful for reading from a file of comma-separated values (CSV)
@scores = split /,/, '32,45,16,5';

# It's also possible to use a postfix for operator and aliasing of
# the $_ magic variable to the next value of the list during each
# iteration; this is pointless here, but similar idioms are widely used
# in some circumstances.
push @scores, $_ foreach 32, 45, 16, 5;
</source>

A hash may be initialized from a list of key/value pairs:

<source lang="perl">
%favorite = (
 joe => 'red',
 sam => 'blue'
);
</source>

The <code>=></code> operator is equivalent to a comma, except that it assumes quotes around the preceding token if it is a bare identifier: <code>(joe => 'red')</code> is the same as <code>('joe' => 'red')</code>. It can therefore be used to elide quote marks, improving readability.

Individual elements of a list are accessed by providing a numerical index, in square brackets. Individual values in a hash are accessed by providing the corresponding key, in curly braces. The <code>$</code> sigil identifies the accessed element as a scalar.

<source lang="perl">
$scores[2] # an element of @scores
$favorite{joe} # a value in %favorite
</source>

Thus, a hash can also be specified by setting its keys individually:

<source lang="perl">
$favorite{joe} = 'red';
$favorite{sam} = 'blue';
</source>

Multiple elements may be accessed by using the <code>@</code> sigil instead (identifying the result as a list).

<source lang="perl">
@scores[2, 3, 1] # three elements of @scores
@favorite{'joe', 'sam'} # two values in %favorite
@favorite{qw(joe sam)} # same as above
</source>

The number of elements in an array can be obtained by evaluating the array in scalar context or with the help of the <code>$#</code> sigil. The latter gives the index of the last element in the array, not the number of elements.

<source lang="perl">
$count = @friends; # Assigning to a scalar forces scalar context

# This notation is sometimes discouraged, because it tends
# to be confused with comments.

$#friends; # The index of the last element in @friends
$#friends+1; # Usually the number of elements in @friends is one more
 # than $#friends because the first element is at index 0,
 # not 1, unless the programmer reset this to a different
 # value, which most Perl manuals discourage.
</source>

There are a few functions that operate on entire hashes.

<source lang="perl">
@names = keys %addressbook;
@addresses = values %addressbook;

# Every call to each returns the next key/value pair.
# All values will be eventually returned, but their order
# cannot be predicted.
while (($name, $address) = each %addressbook) {
 print "$name lives at $address\n";
}

# Similar to the above, but sorted alphabetically
foreach my $next_name (sort keys %addressbook) {
 print "$next_name lives at $addressbook{$next_name}\n";
}
</source>

=== Control structures ===
{{main|Perl control structures}}

Perl has several kinds of control structures.

It has block-oriented control structures, similar to those in the C, [[Javascript]], and [[Java (programming language)|Java]] programming languages. Conditions are surrounded by parentheses, and controlled blocks are surrounded by braces:

 ''label'' while ( ''cond'' ) { ... }
 ''label'' while ( ''cond'' ) { ... } continue { ... }
 ''label'' for ( ''init-expr'' ; ''cond-expr'' ; ''incr-expr'' ) { ... }
 ''label'' foreach ''var'' ( ''list'' ) { ... }
 ''label'' foreach ''var'' ( ''list'' ) { ... } continue { ... }
 if ( ''cond'' ) { ... }
 if ( ''cond'' ) { ... } else { ... }
 if ( ''cond'' ) { ... } elsif ( ''cond'' ) { ... } else { ... }

Where only a single statement is being controlled, statement modifiers provide a more concise syntax:

 ''statement'' if ''cond'' ;
 ''statement'' unless ''cond'' ;
 ''statement'' while ''cond'' ;
 ''statement'' until ''cond'' ;
 ''statement'' foreach ''list'' ;

[[Short-circuit evaluation|Short-circuit logical operators]] are commonly used to affect control flow at the expression level:

 ''expr'' and ''expr''
 ''expr'' && ''expr''
 ''expr'' or ''expr''
 ''expr'' <nowiki>||</nowiki> ''expr''

(The "and" and "or" operators are similar to && and <nowiki>||</nowiki> but have lower [[precedence]], which makes it easier to use them to control entire statements.)

The flow control keywords <code>next</code> (corresponding to C's <code>continue</code>), <code>last</code> (corresponding to C's <code>break</code>), <code>return</code>, and <code>redo</code> are expressions, so they can be used with short-circuit operators.

Perl also has two implicit looping constructs, each of which has two forms:

 ''results'' = grep { ... } ''list''
 ''results'' = grep ''expr'', ''list''
 ''results'' = map { ... } ''list''
 ''results'' = map ''expr'', ''list''

<code>grep</code> returns all elements of ''list'' for which the controlled block or expression evaluates to true. <code>map</code> evaluates the controlled block or expression for each element of ''list'' and returns a list of the resulting values. These constructs enable a simple [[functional programming]] style.

Up until the 5.10.0 release, there was no [[switch statement]] in Perl 5. From 5.10.0 onwards, a multi-way branch statement called <code>given</code>/<code>when</code> is available, which takes the following form:

 given ( ''expr'' ) { when ( ''cond'' ) { ... } default { ... } }

Syntactically, this structure behaves similarly to [[switch statement]]'s found in other languages, but with a few important differences.  The largest is that unlike switch/case structures, given/when statements break execution after the first successful branch, rather than waiting for explicitly defined break commands.  Conversely, explicit continues are instead necessary to emulate switch behavior.

For those not using the 5.10.0 release, the Perl documentation describes a half-dozen ways to achieve the same effect by using other control structures. There is also a [http://search.cpan.org/perldoc/Switch Switch] module, which provides functionality modeled on the forthcoming [[Perl 6]] re-design.

Perl includes a <code>goto label</code> statement, but it is rarely used. Situations where a <code>goto</code> is called for in other languages don't occur as often in Perl due to its breadth of flow control options.

There is also a <code>goto &sub</code> statement that performs a [[tail call]]. It terminates the current subroutine and immediately calls the specified <code>''sub''</code>. This is used in situations where a caller can perform more efficient [[Call stack|stack]] management than Perl itself (typically because no change to the current stack is required), and in deep recursion tail calling can have substantial positive impact on performance because it avoids the overhead of scope/stack management on return.

=== Subroutines ===
[[Subroutine]]s are defined with the <code>sub</code> keyword, and invoked simply by naming them. If the subroutine in question has not yet been declared, invocation requires either parentheses after the function name or an ampersand ('''&''') before it.

<source lang="perl">
# Calling a subroutine

# Parentheses are required here if the subroutine is defined later in the code
foo();
&foo; # (this also works)

# Defining a subroutine
sub foo { ... }

foo; # Here parentheses are not required
</source>

A list of arguments may be provided after the subroutine name. Arguments may be scalars, lists, or hashes.

<source lang="perl">
foo $x, @y, %z;
</source>
The parameters to a subroutine do not need to be declared as to either number or type; in fact, they may vary from call to call. Any validation of parameters must be performed explicitly inside the subroutine.

Arrays are expanded to their elements, hashes are expanded to a list of key/value pairs, and the whole lot is passed into the subroutine as one flat list of scalars.

Whatever arguments are passed are available to the subroutine in the special array <code>@_</code>. The elements of <code>@_</code> are aliased to the actual arguments; changing an element of <code>@_</code> changes the corresponding argument.

Elements of <code>@_</code> may be accessed by subscripting it in the usual way.

<source lang="perl">
$_[0], $_[1]
</source>

However, the resulting code can be difficult to read, and the parameters have [[Evaluation strategy#Call by reference|pass-by-reference]] semantics, which may be undesirable.

One common idiom is to assign <code>@_</code> to a list of named variables.

<source lang="perl">
 my ($x, $y, $z) = @_;
</source>

This provides mnemonic parameter names and implements [[Evaluation strategy#Call by value|pass-by-value]] semantics. The <code>my</code> keyword indicates that the following variables are lexically scoped to the containing block.

Another idiom is to shift parameters off of <code>@_</code>. This is especially common when the subroutine takes only one argument, or for handling the <code>$self</code> argument in object-oriented modules.

<source lang="perl">
my $x = shift;
</source>

Subroutines may assign <code>@_</code> to a hash to simulate named arguments; this is recommended in ''Perl Best Practices'' for subroutines that are likely ever to have more than three parameters.<ref>
Damian Conway, ''[http://www.oreilly.com/catalog/perlbp/chapter/ch09.pdf Perl Best Practices]'', p.182</ref>

<source lang="perl">
sub function1 {
 my %args = @_;
 print "'x' argument was '$args{x}'\n";
}
function1( x => 23 );
</source>

Subroutines may return values.

<source lang="perl">
return 42, $x, @y, %z;
</source>

If the subroutine does not exit via a <code>return</code> statement, then it returns the last expression evaluated within the subroutine body. Arrays and hashes in the return value are expanded to lists of scalars, just as they are for arguments.

The returned expression is evaluated in the calling context of the subroutine; this can surprise the unwary.

<source lang="perl">
sub list { (4, 5, 6) }
sub array { @x = (4, 5, 6); @x }

$x = list; # returns 6 - last element of list
$x = array; # returns 3 - number of elements in list
@x = list; # returns (4, 5, 6)
@x = array; # returns (4, 5, 6)
</source>

A subroutine can discover its calling context with the <code>wantarray</code> function.

<source lang="perl">
sub either {
 return wantarray ? (1, 2) : "Oranges";
}

$x = either; # returns "Oranges"
@x = either; # returns (1, 2)
</source>

=== Regular expressions ===
The Perl language includes a specialized syntax for writing [[regular expression]]s (RE, or regexes), and the interpreter contains an engine for matching strings to regular expressions. The regular expression engine uses a [[backtracking]] algorithm, extending its capabilities from simple pattern matching to string capture and substitution. The regular expression engine is derived from regex written by [[Henry Spencer]].

The Perl regular expression syntax was originally taken from Unix Version 8 regular expressions. However, it diverged before the first release of Perl, and has since grown to include many more features. Other languages and applications are now adopting [[PCRE|Perl compatible regular expressions]] over [[POSIX]] regular expressions including [[PHP]], [[Ruby programming language|Ruby]], [[Java (programming language)|Java]], Microsoft's [[.NET Framework]]<ref>Microsoft Corp., ".NET Framework Regular Expressions", ''.NET Framework Developer's Guide'', [http://msdn2.microsoft.com/en-us/library/hs600312(VS.71).aspx]</ref>, and the [[Apache HTTP server]].

Regular expression syntax is extremely compact, owing to history. The first regular expression dialects were only slightly more expressive than [[Glob (programming)|globs]], and the syntax was designed so that an expression would resemble the text it matches{{Fact|date=June 2007}}. This meant using no more than a single punctuation character or a pair of delimiting characters to express the few supported assertions. Over time, the expressiveness of regular expressions grew tremendously, but the syntax design was never revised and continues to rely on punctuation. As a result, regular expressions can be cryptic and extremely dense.

==== Uses ====
The <code>m//</code> (match) operator introduces a regular expression match. (If it is delimited by slashes, as in all the examples here, then the leading <code>m</code> may be omitted for brevity. If the <code>m</code> is present, as in all the following examples, other delimiters can be used in place of slashes.) In the simplest case, an expression like

<source lang="perl">
$x =~ m/abc/
</source>

evaluates to true [[if and only if]] the string <code>$x</code> matches the regular expression <code>abc</code>.

The <code>s///</code> (substitute) operator, on the other hand, specifies a search and replace operation:

<source lang="perl">
$x =~ s/abc/aBc/; # upcase the b
</source>

Another use of regular expressions is to specify delimiters for the <code>split</code> function:

<source lang="perl">
@words = split m/,/, $line;
</source>

The <code>split</code> function creates a list of the parts of the string separated by matches of the regular expression. In this example, a line is divided into a list of its comma-separated parts, and this list is then assigned to the <code>@words</code> array.

==== Syntax ====
Portions of a regular expression may be enclosed in parentheses; corresponding portions of a matching string are ''captured''. Captured strings are assigned to the sequential built-in variables <code>$1, $2, $3, ...</code>, and a list of captured strings is returned as the value of the match.

<source lang="perl">
$x =~ m/a(.)c/; # capture the character between 'a' and 'c'
</source>

Perl regular expressions can take ''modifiers''. These are single-letter suffixes that modify the meaning of the expression:

<source lang="perl">
$x =~ m/abc/i; # case-insensitive pattern match
$x =~ s/abc/aBc/g; # global search and replace
</source>

Since regular expressions can be dense and cryptic because of their compact syntax, the <code>/x</code> modifier was added in Perl to help programmers write more legible regular expressions. It allows programmers to place whitespace and comments ''inside'' regular expressions:

<source lang="perl">
$x =~ m/a # match 'a'
 . # followed by any character
 c # then followed by the 'c'character
 /x;
</source>

== Database interfaces ==
Perl is widely favored for database applications. Its text handling facilities are useful for generating [[SQL]] queries; arrays, hashes and automatic memory management make it easy to collect and process the returned data.

In early versions of Perl, database interfaces were created by relinking the interpreter with a client-side database library. This was sufficiently difficult that it was only done for a few of the most important and widely used databases, and restricted the resulting <code>perl</code> executable to using just one database interface at a time.

In Perl 5, database interfaces are implemented by [[Perl DBI]] modules. The DBI (Database Interface) module presents a single, database-independent interface to Perl applications, while the DBD (Database Driver) modules handle the details of accessing some 50 different databases; there are DBD drivers for most [[American National Standards Institute|ANSI]] [[SQL]] databases.

DBI provides caching for database handles and queries, which can greatly improve performance in long-lived execution environments such as [[mod_perl]]<ref>{{cite web | last = Bekman | first = Stas | title = Efficient Work with Databases under mod_perl | url = http://perl.apache.org/docs/1.0/guide/performance.html#Efficient_Work_with_Databases_under_mod_perl | accessdate = 2007-09-01 }}</ref>, helping high-volume systems avert load spikes as in the [[Slashdot effect]].

== Comparative performance ==
''The Computer Language Benchmarks Game''<ref>[http://shootout.alioth.debian.org/ The Computer Language Benchmarks Game<!-- Bot generated title -->]</ref> compare the performance of implementations of typical programming problems in several programming languages. The submitted Perl implementations were typically towards the high end of the memory usage spectrum, and had varied speed results. Perl's performance in the benchmarks game is similar to other interpreted languages such as Python, faster than PHP, and significantly faster than Ruby, but slower than most compiled languages.

Perl programs can start slower than similar programs in compiled languages because perl has to compile the source every time it runs. In a talk at the [[YAPC|YAPC::Europe 2005]] conference and subsequent article, "A Timely Start", Jean-Louis Leroy found that his Perl programs took much longer to run than he expected because the perl interpreter spent much of the time finding modules because of his over-large include path.<ref>{{cite web | url=http://www.perl.com/pub/a/2005/12/21/a_timely_start.html | title=A Timely Start | author=Leroy, Jean-Louis | date=2005-12-01 | publisher=Perl.com }}</ref> Because pre-compiling is still an experimental part of Perl<ref>{{cite web | url=http://search.cpan.org/~nwclark/perl-5.8.8/ext/B/B/Bytecode.pm#KNOWN_BUGS | title=B::Bytecode Perl compiler's bytecode backend | author=Beattie, Malcolm and Enache Adrian | year=2003 | publisher=search.cpan.org }}</ref> – unlike that of Java, Python, and Ruby – Perl programs pay this overhead penalty on every execution. When [[amortized]] over a long run phase, startup time is not typically substantial, but measurement of very short execution times can often be skewed as is often found in benchmarks.

A number of tools have been introduced to improve this situation, the first of which was Apache's [[mod_perl]], which sought to address one of the most common reasons that small Perl programs were invoked rapidly: [[Common Gateway Interface|CGI]] [[World Wide Web|Web]] development. [[ActiveState|ActivePerl]], via Microsoft [[ISAPI]] provides similar performance improvements.

Once Perl code is compiled, there is additional overhead during the execution phase that typically isn't present for programs written in compiled languages like C or C++, including, among many other things, overhead due to bytecode interpretation, reference-counting memory management, and dynamic type checking.